# 数组与字符串

## 一、集合、列表和数组

### （1）集合

**定义为：由一个或多个确定的元素所构成的整体。**

集合特性：

首先，**集合里的元素类型不一定相同**。 

其次，**集合里的元素没有顺序**。 

事实上，这样的集合并不直接存在于编程语言中。然而，实际编程语言中的很多数据结构，就是**在集合的基础上添加了一些规则形成的。**

### （2）列表

**定义为：是一种数据项构成的有限序列，即按照一定的线性顺序，排列而成的数据项的集合。**

**列表的概念是在集合的特征上形成的，它具有顺序，且长度是可变的。**

列表最常见的表现形式有**数组和链表**，而我们熟悉的**栈和队列则是两种特殊类型的列表。**

### （3）数组

数组是列表的实现方式，它**具有列表的特征**，同时也具有自己的一些特征。

*C++ 和 Java 中，数组中的元素类型必须保持一致，而 Python 中则可以不同。Python 中的数组叫做 list，具有更多的高级功能。*

从宏观上区分列表和数组，需要一个重要的概念：**索引**。

**而列表中没有索引，这是数组与列表最大的不同点。**

![img](https://pic.leetcode-cn.com/628b6f699aa49ffcc9d3c75806457c4a1a66ffe025bb651d9f8e78b4242249b9-4.png)

**索引从0开始。**

*数组中的元素在内存中是连续存储的，且每个元素占用相同大小的内存。*

*相反，列表中的元素在内存中可能彼此相邻，也可能不相邻。比如列表的另一种实现方式——链表，它的元素在内存中则不一定是连续的。*

## 二、数组的操作

### （1）读取元素

对于数组，计算机会在内存中为其申请一段 **连续** 的空间，并且会记下索引为 0 处的内存地址。

计算机需要寻找某个索引的内容时候，就只需要将 0 索引处的地址加上要寻找内容的索引值即可找到其地址。

*而这个过程是很快的，直接访问地址找到内容时间复杂度为常数级，为 O(1)。*

### （2）查找元素

查找一个数组内的元素最多需要查找 **n 次**（为数组的长度）。

*因此查找元素的时间复杂度为 O(N)。*

### （3）插入元素

如果要将该元素插入到数组的末尾，只需要一步。即计算机通过数组的长度和位置计算出即将插入元素的内存地址，然后将该元素插入到指定位置即可。

然而，如果要将该元素插入到数组中的其他位置，则会有所区别，这时我们首先需要为该元素所要插入的位置 **腾出** 空间，然后进行插入操作。

如果需要频繁地对数组元素进行插入操作，会造成时间的浪费。

*事实上，另一种数据结构，即**链表**可以有效解决这个问题。*

### （4）删除元素

删除元素与插入元素的操作类似，当我们删除掉数组中的某个元素后，数组中会留下 **空缺** 的位置，而数组中的元素在内存中是连续的，这就使得后面的元素需对该位置进行 **填补** 操作。

当数组的长度为 **n** 时，最坏情况下，我们删除第一个元素，共需要的步骤数为 **1 + (n - 1) = n** 步，其中，**1** 为删除操作，n - 1 为移动其余元素的步骤数。

*删除操作具有线性时间复杂度，即时间复杂度为 O(N)，N 为数组的长度。*



## *例题1* 寻找中心数索引

Given an array of integers nums, calculate the pivot index of this array.

The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right.

If the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to the right edge of the array.

Return the leftmost pivot index. If no such index exists, return -1.

Example 1:

```
Input: nums = [1,7,3,6,5,6]
Output: 3
Explanation:
The pivot index is 3.
Left sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11
Right sum = nums[4] + nums[5] = 5 + 6 = 11
```

Example 2:

```
Input: nums = [1,2,3]
Output: -1
Explanation:
There is no index that satisfies the conditions in the problem statement.
```

Example 3:

```
Input: nums = [2,1,-1]
Output: 0
Explanation:
The pivot index is 0.
Left sum = 0 (no elements to the left of index 0)
Right sum = nums[1] + nums[2] = 1 + -1 = 0
```


Constraints:

```
1 <= nums.length <= 104
-1000 <= nums[i] <= 1000
```

**方法1：**左边的和×2加上当前数值等于总和时，当前索引即为中心数字索引。

```python
class Solution:
    def pivotIndex(self, nums: List[int]) -> int:
        all = sum(nums)
        left_sum = 0
        for i in range(len(nums)):
            if left_sum * 2 + nums[i] == all:
                return i
            else:
                left_sum += nums[i]
        return -1
```

*执行用时：44 ms, 在所有 Python3 提交中击败了92.55%的用户*

*内存消耗：16 MB, 在所有 Python3 提交中击败了35.04%的用户*

*通过测试用例：745 / 745*

**方法2：**总和不断减数，左边和不断加数，直到两者相等时找到索引。

```python
class Solution:
    def pivotIndex(self, nums: List[int]) -> int:
        left_sum = 0
        total = sum(nums)
        for i, num in enumerate(nums):
            total -= num
            if left_sum == total: return i
            left_sum += num
        return -1
```

## *例题2* 搜索插入位置

Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You must write an algorithm with O(log n) runtime complexity.

Example 1:

```
Input: nums = [1,3,5,6], target = 5
Output: 2
```

Example 2:

```
Input: nums = [1,3,5,6], target = 2
Output: 1
```

Example 3:

```
Input: nums = [1,3,5,6], target = 7
Output: 4
```


Constraints:

```
1 <= nums.length <= 104
-104 <= nums[i] <= 104
nums contains distinct values sorted in ascending order.
-104 <= target <= 104
```

**方法1：**就直接暴力遍历即可

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        for i in range(len(nums)):
            if nums[i] < target:
                if i == len(nums) - 1:
                    return len(nums)
                continue
            elif nums[i] >= target:
                return i
```

**方法2：**所谓**二分法**查找，只要提到**排序的数组**，我们首先要考虑的就是能不能使用二分法。这题很明显是可以的。二分法后面再学。

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        if len(nums) < 1: return 0
        left = 0
        right = len(nums) - 1  # 这里使用闭区间
        while(left <= right):
            mid = left + (right - left) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] > target:
                right = mid - 1
            else:
                left = mid + 1
        return right + 1
```

## *例题3* 合并重叠区间 （二维数组）

Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.

Example 1:

```
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].
```

Example 2:

```
Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
```


Constraints:

```
1 <= intervals.length <= 104
intervals[i].length == 2
0 <= starti <= endi <= 104
```

**方法1：**

```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        """
        方法：排序
        """
        intervals.sort(key = lambda x : x[0])
        merges = list()
        for interval in intervals:
            if not merges or merges[-1][-1] < interval[0]:
                merges.append(interval)
            else:
                merges[-1][-1] = max(merges[-1][-1], interval[1])
        return merges
```

## 三、二维数组

二维数组是一种结构较为特殊的数组，只是将数组中的**每个元素变成了一维数组。**

所以二维数组的**本质上仍然是一个一维数组**，内部的一维数组仍然从索引  0 开始，我们可以将它看作一个矩阵，并处理矩阵的相关问题。（矩阵旋转、对角线遍历，以及对子矩阵的操作等。）

## *例题1* 旋转矩阵

Given an image represented by an N x N matrix, where each pixel in the image is 4 bytes, write a method to rotate the image by 90 degrees. Can you do this in place?

Example 1:

```
Given matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

Rotate the matrix in place. It becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

Example 2:

```
Given matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

Rotate the matrix in place. It becomes:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
```

**方法1：** 

矩阵的**逆时针旋转90°：**先把**主对角线**两边的元素互换，再**垂直镜像**翻转。

矩阵的**顺时针旋转90°：**先把**主对角线**两边的元素互换，再**水平镜像**翻转。

```python
import numpy as np
b = [[ 5, 1, 9,11],[ 2, 4, 8,10],[13, 3, 6, 7],[15,14,12,16]]
b  = np.array(b)
n = len(b)
print(b)
print('\n')

'''顺时针旋转'''
def clockwise_rot(b,n):
    # 交换主对角线两旁元素
    for i in range(n):
        for j in range(i):
            temp = b[i][j]
            b[i][j] = b[j][i]
            b[j][i] = temp
    # 水平镜像翻转
    for i in range(n):
        for j in range(n//2):
            temp1 = b[i][j]
            b[i][j] = b[i][-1-j]
            b[i][-1-j] = temp1
    
    print('clockwise_rot:'+'\n')
    print(b,'\n')

'''逆时针旋转矩'''
def anti_clockwise_rot(b,n):
    # 交换主对角线两旁元素
    for i in range(n):
        for j in range(i):
            temp = b[i][j]
            b[i][j] = b[j][i]
            b[j][i] = temp
    # 垂直镜像翻转
    for i in range(n):
        for j in range(n//2):
            temp2 = b[j][i]
            b[j][i] = b[-1-j][i]
            b[-1-j][i] = temp2
    print('anti_clockwise_rot:'+'\n')
    print(b,'\n')

if __name__ == '__main__':
    # 任选一个函数
    #clockwise_rot(b,n)
    #anti_clockwise_rot(b,n)
```

**方法2：**zip，一行搞定。

```python
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        
        matrix[:]=zip(*matrix[::-1])
```

## *例题2* 零矩阵

Write an algorithm such that if an element in an MxN matrix is 0, its entire row and column are set to 0.

Example 1:

```
Input: 
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
Output: 
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]
```

Example 2:

```
Input: 
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
Output: 
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
```

**方法1：**记录下零元素位置，这样思路清晰简单但是内存占用大。

```python
import numpy as np
b = [[ 0, 1, 2, 0],[ 3, 4, 5, 2],[1, 3, 1, 5]]
b  = np.array(b)
n = len(b)
m = len(b[0])
print('oringnal'+'\n')
print(b)
row = []
column = []

for i in range(n):
    for j in range(m):
        if b[i][j] == 0:
            row.append(i)
            column.append(j)

len = len(row)
# row = 0
for i in range(len):
    for j in range(m):
        b[row[i]][j] = 0
# column = 0
for i in range(len):
    for j in range(n):
        b[j][column[i]] = 0

print('set_zeros'+'\n')
print(b)
```

方法2：不需要记录确切零元素位置，只需要知道某行某列有零元素即可。

```python
import numpy as np
from numpy import piecewise
b = [[ 0, 1, 2, 0],[ 3, 4, 5, 2],[1, 3, 1, 5]]
b  = np.array(b)
n = len(b)
m = len(b[0])
print('oringnal'+'\n')
print(b)
row = []
column = []
# 检查行有无零元素
for i in range(n):
    for j in range(m):
        if b[i][j] == 0:
            row.append(i)

# 检查列有无零元素
for i in range(n):
    for j in range(m):
        if b[i][j] == 0:
            column.append(j)

row = list(set(row))
cloumn = list(set(column))

l = len(row)
l1 = len(column)
# row = 0
for i in range(l):
    for j in range(m):
        b[row[i]][j] = 0

# column = 0
for i in range(l1):
    for j in range(n):
        b[j][column[i]] = 0

print('set_zeros'+'\n')
print(b)
```

## *例题3* 对角线遍历

Given an m x n matrix mat, return an array of all the elements of the array in a diagonal order.

Example 1:

![img](https://assets.leetcode.com/uploads/2021/04/10/diag1-grid.jpg)

```
Input: mat = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,2,4,7,5,3,6,8,9]
```

Example 2:

```
Input: mat = [[1,2],[3,4]]
Output: [1,2,3,4]
```


Constraints:

```
m == mat.length
n == mat[i].length
1 <= m, n <= 104
1 <= m * n <= 104
-105 <= mat[i][j] <= 105
```

**方法1：** 思想为：一条对角线上的和相同，和为偶数时向上遍历，和为奇数时向下遍历。但是这样有很多元素被遍历但超出矩阵边界而被舍弃，时间复杂度高，速度奇慢！

```python
class Solution:
    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:
        m = len(mat)
        n = len(mat[0])
        out = []
        for sum in range(m + n - 1):
            if sum % 2 == 0:
                for i in range(sum + 1):
                    if i >= n or sum-i >= m:
                        continue
                    out.append(mat[sum - i][i])
            else:
                for i in range(sum + 1):
                    if i >= m or sum-i >= n:
                        continue
                    out.append(mat[i][sum - i])
        return out
```

![image-20220730212944596](C:\Users\24372\AppData\Roaming\Typora\typora-user-images\image-20220730212944596.png)

8000ms也太慢了吧！

方法2：优化猜想：减少元素的循环遍历次数，采用while和循环变量加减操作来**减少时间复杂度。**

```python
class Solution:
    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix:
            return []
        m = len(matrix) #行数
        n = len(matrix[0]) #列数
        tot = m + n - 1 #对角线条数
        res = []
        r, c = 0, 0  # r为横坐标，c为纵坐标，初始值都为零
        for i in range(tot):
            if i % 2 == 0:
                while r >= 0 and c < n: 
                #向右上遍历时，只要横坐标不小于零（不超过上边界）且纵坐标小于行数（不超过右边界）
                    res.append(matrix[r][c]) #不超过上、右边界的通过r,c的代入，映射出坐标对应值放入列表。
                    r -= 1 #横坐标向上移动一格
                    c += 1 #纵坐标向右移动一格
                    #两个动作结合就是坐标点往右上移动一格后，再次通过while判断是否写入结果列表
                if c < n:
#运行到这一步时说明此时此刻节点的r等于-1了，超出了上边界这时需要先判断c是否超出右边界，如果没有超出则r+=1把r横坐标拉回上边界这里只判断一次，相当于已经遍历完一条对角线后，把坐标点放到下一个对角线的起始点上。
                    r += 1
                else:
#运行到这一步时说明此时此刻节点的r等于-1了，超出了上边界与此同时c=-1超过了右边界，注意这种情况会发生在该对角线起始点或终止点遇到两条边界交点后（包含）持续发生每次超过右边界时，也只操作一次c -= 1拉回到右边界，r += 2（一共2格，回到原来超出前位置算一格，往下走一格。
                    r += 2
                    c -= 1
            else:
                while c >= 0 and r < m: 
                    res.append(matrix[r][c])
                    r += 1
                    c -= 1
                if r < m:
                    c += 1
                else:
                    c += 2
                    r -= 1
        return res
```

![image-20220730212847654](C:\Users\24372\AppData\Roaming\Typora\typora-user-images\image-20220730212847654.png)

## 四、字符串

[维基百科](https://zh.wikipedia.org/wiki/字符串)：字符串是由零个或多个字符组成的有限序列。一般记为 s = a1a2...an。它是编程语言中表示文本的数据类型。

*1.字符串的基本操作对象通常是**字符串整体或者其子串***

*2. 字符串操作比其他数据类型更复杂（例如比较、连接操作）*

### （1）字符串比较

字符串有它自己的比较函数（我们将在下面的代码中向你展示比较函数的用法）。

然而，存在这样一个问题：

我们可以用 “==” 来比较两个字符串吗？

这取决于下面这个问题的答案：

我们使用的语言是否支持运算符重载？

如果答案是 yes （例如 C++、Python）。我们可以使用 == 来比较两个字符串；
如果答案是 no （例如 Java），我们可能无法使用 == 来比较两个字符串。当我们使用 == 时，它实际上会比较这两个对象是否是同一个对象。

### （2）字符串连接

对于不同的编程语言中，字符串可能是可变的，也可能是不可变的。**不可变意味着一旦字符串被初始化，你就无法改变它的内容。**

在某些语言（如 C ++）中，字符串是可变的。 也就是说，你可以**像在数组中那样修改字符串。**
在其他一些语言（如 Java、**Python**）中，**字符串是不可变的。**

### （3）字符串匹配算法：KMP

### （4）双指针技巧

**情景一：**

反转数组中的元素。比如数组为 ['l', 'e', 'e', 't', 'c', 'o', 'd', 'e']，反转之后变为 ['e', 'd', 'o', 'c', 't', 'e', 'e', 'l']。

使用双指针技巧，其思想是分别将两个指针分别指向数组的开头及末尾，然后将其指向的元素进行交换，再将指针向中间移动一步，继续交换，直到这两个指针相遇。

**使用双指针的典型场景之一是你想要从两端向中间迭代数组。**

**一个指针从头部开始，而另一个指针从尾部开始。**

这种技巧经常在 *排序数组* 中使用。

**情景二：**

有时，我们可以使用两个不同步的指针来解决问题，即快慢指针。与情景一不同的是，两个指针的运动方向是相同的，而非相反。

给你一个数组 `nums` 和一个值 `val`，你需要 **原地** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

如果我们不使用额外的数组，只是在原数组上进行操作：

此时，我们就可以采用快慢指针的思想：**初始化一个快指针 fast 和一个慢指针 slow，fast 每次移动一步，而 slow 只当 fast 指向的值不等于 val 时才移动一步。**

#### *双指针例题1* 数组拆分

Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), ..., (an, bn) such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum.



Example 1:

```
Input: nums = [1,4,3,2]
Output: 4
Explanation: All possible pairings (ignoring the ordering of elements) are:

(1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3

(1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3

(1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4
So the maximum possible sum is 4.
```

Example 2:

```
Input: nums = [6,2,6,5,1,2]
Output: 9
Explanation: The optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.
```

方法1：！！！注意sotr()函数的运用。

```python
class Solution(object):
    def arrayPairSum(self, nums):
        nums.sort()
        res = 0
        for i in range(0, len(nums), 2):
            res += min(nums[i], nums[i + 1])
        return res
```

方法2：切片操作比循环快。

```python
class Solution(object):
    def arrayPairSum(self, nums):
        nums.sort()
        return sum(nums[::2])
```

方法3：sorted复制了新数组，占用更多内存。

```python
class Solution(object):
    def arrayPairSum(self, nums):
        return sum(sorted(nums)[::2])
```

#### *双指针例题2* 两数之和—输入非减数组

Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.

Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.

The tests are generated such that there is exactly one solution. You may not use the same element twice.

Your solution must use only constant extra space.

 

Example 1:

```
Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].
```

Example 2:

```
Input: numbers = [2,3,4], target = 6
Output: [1,3]
Explanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3].
```

Example 3:

```
Input: numbers = [-1,0], target = -1
Output: [1,2]
Explanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2].
```


Constraints:

```
2 <= numbers.length <= 3 * 104
-1000 <= numbers[i] <= 1000
numbers is sorted in non-decreasing order.
-1000 <= target <= 1000
The tests are generated such that there is exactly one solution.
```

方法：

由于数组从小到大排列, 双指针分别指向首部和尾部;

**首部尾部相加等于目标值，返回结果集arry**
**首部尾部相加小于目标值，尾部前移变大**
**首部尾部相加大于目标值，首部后移变小**

```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        arry = [] # 也可以不用新的数组，直接返回[slow+1, fast+1]也可以，能够降低内存使用量。
        slow = 0
        fast = len(numbers) - 1
        while numbers[slow] + numbers[fast] != target:
            if numbers[slow] + numbers[fast] > target:
                fast -= 1
            elif numbers[slow] + numbers[fast] < target:
                slow += 1
        arry.append(slow+1)
        arry.append(fast+1)
        return arry  # or return [slow+1, fast+1]
```



#### *双指针例题3* 移除元素

Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.

Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.

Return k after placing the final result in the first k slots of nums.

Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.

Custom Judge:

The judge will test your solution with the following code:

```
int[] nums = [...]; // Input array
int val = ...; // Value to remove
int[] expectedNums = [...]; // The expected answer with correct length.
                            // It is sorted with no values equaling val.

int k = removeElement(nums, val); // Calls your implementation

assert k == expectedNums.length;
sort(nums, 0, k); // Sort the first k elements of nums
for (int i = 0; i < actualLength; i++) {
    assert nums[i] == expectedNums[i];
}
```

If all assertions pass, then your solution will be accepted.

Example 1:

```
Input: nums = [3,2,2,3], val = 3
Output: 2, nums = [2,2,_,_]
Explanation: Your function should return k = 2, with the first two elements of nums being 2.
It does not matter what you leave beyond the returned k (hence they are underscores).
```

Example 2:

```
Input: nums = [0,1,2,2,3,0,4,2], val = 2
Output: 5, nums = [0,1,4,0,3,_,_,_]
Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.
Note that the five elements can be returned in any order.
It does not matter what you leave beyond the returned k (hence they are underscores).
```


Constraints:

```
0 <= nums.length <= 100
0 <= nums[i] <= 50
0 <= val <= 100
```

方法：

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        slow = 0
        n = len(nums)
        count = 0
        for fast in range(n):
            if nums[fast] != val:
                nums[slow] = nums[fast]
                slow += 1
                count += 1
        return count
```

#### *双指针例题4* 最大连续1的个数

Given a binary array nums, return the maximum number of consecutive 1's in the array.

Example 1:

```
Input: nums = [1,1,0,1,1,1]
Output: 3
Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.
```

Example 2:

```
Input: nums = [1,0,1,1,0,1]
Output: 2
```


Constraints:

```
1 <= nums.length <= 105
nums[i] is either 0 or 1.
```

方法：

```python
class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        count = 0
        n = len(nums)
        ones = []
        for fast in range(n):
            if nums[fast] == 1:
                count += 1
            elif nums[fast] != 1:
                ones.append(count)
                count = 0
            if fast == n - 1:
                ones.append(count)
        max = ones[0]
        for i in range(1, len(ones)):
            if ones[i] > max:
                max = ones[i]
        
        return max
```

#### *双指针例题5* 长度最小的子数组

Given an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray [numsl, numsl+1, ..., numsr-1, numsr] of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead.

Example 1:

```
Input: target = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: The subarray [4,3] has the minimal length under the problem constraint.
```

Example 2:

```
Input: target = 4, nums = [1,4,4]
Output: 1
```

Example 3:

```
Input: target = 11, nums = [1,1,1,1,1,1,1,1]
Output: 0
```


Constraints:

```
1 <= target <= 109
1 <= nums.length <= 105
1 <= nums[i] <= 104
```

Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).

方法1：这个方法要超时AC不了

```python
nums = [2,3,1,2,4,3]
target = 7
sum = 0
arry = []
for slow in range(len(nums)):
    fast = slow
    sum = 0
    while fast < (len(nums)):
        sum += nums[fast]
        if sum >= target:
            sum = 0
            arry.append(fast - slow + 1)
            break
        fast += 1
if not arry:
    print(0)
else:
    print(min(arry))
```

方法2：双指针：尺取法

```python
nums = [2,3,1,2,4,3]
target = 7
left, right = 0, 0
sum = 0
count = len(nums) + 1 # 全部加起来刚好是target和仍然不满足target的分界
for right in range(len(nums)):
    sum += nums[right]
    while sum >= target:
        count = min(right - left + 1, count)
        sum -= nums[left]
        left += 1
if count == len(nums) + 1:
    print(0)
else:
    print(count)
```



## *例题1* 最长公共前缀（5 methods）

Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string "".

Example 1:

```
Input: strs = ["flower","flow","flight"]
Output: "fl"
```

Example 2:

```
Input: strs = ["dog","racecar","car"]
Output: ""
Explanation: There is no common prefix among the input strings.
```


Constraints:

```
1 <= strs.length <= 200
0 <= strs[i].length <= 200
strs[i] consists of only lowercase English letters.
```

方法1：使用zip

```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        ret = ''
        #使用zip
        for i in zip(*strs):
            if len(set(i)) == 1:
                ret += i[0]
            else:
                break
        return ret
```

方法2：横向遍历

```python
def longestCommonPrefix1(strs):
    if not strs:
        return ''
    prefix, count = strs[0], len(strs)
    for i in range(1,count):
        prefix = lcp(prefix, strs[i])
        if not prefix:
            break

    return prefix

def lcp(str1, str2):
    length = min(len(str1), len(str2))
    index = 0
    while index < length and str1[index] == str2[index]:
        index += 1
    return str2[:index]
```

方法3：纵向遍历

```python
def longestCommonPrefix2(strs):
    if not strs:
        return ''
    for i in range(len(strs[0])):
        c = strs[0][i]
        for j in range(1, len(strs)):
            if strs[j][i] != c or i == len(strs[j]):
                return strs[0][:i]
```

方法4：分治法

```python

```

方法5：二分法

```python

```

## *例题2* 最长回文子串

Given a string s, return the longest palindromic substring in s.

Example 1:

```
Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer.
```

Example 2:

```
Input: s = "cbbd"
Output: "bb"
```


Constraints:

```
1 <= s.length <= 1000
s consist of only digits and English letters.
```

方法1：中心扩散双指针

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        def help(s,left,right):
            while left >= 0 and right < len(s) and s[left] == s[right]:
                left -= 1
                right += 1
            return s[left+1:right]

        res = ''
        for i in range(len(s)):
            sub1 = help(s,i,i)
            sub2 = help(s,i,i+1)
            if len(sub1) > len(res):
                res = sub1
            if len(sub2) > len(res):
                res = sub2
        return res
```

方法2：**动态规划**

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        if n == 1:
            return s
        # 初始化
        dp = [[False]*n for _ in range(n)]
        start = 0
        max_lenth = 1
        for j in range(1,n): 
            for i in range(j):
                if j-i < 3:
                    if s[i] == s[j]:
                        dp[i][j] = True
                        curr_lenth = j-i+1
                else:
                    if s[i] == s[j] and dp[i+1][j-1]:
                        dp[i][j] = True
                        curr_lenth = j-i+1
                # 出现回文则更新start和max_lenth
                if dp[i][j]:
                    if curr_lenth > max_lenth:
                        max_lenth = curr_lenth
                        start = i
        return s[start:start+max_lenth]
```



## *例题3* 翻转字符串里的单词

Given an input string s, reverse the order of the words.

A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.

Return a string of the words in reverse order concatenated by a single space.

Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.

 

Example 1:

```
Input: s = "the sky is blue"
Output: "blue is sky the"
```

Example 2:

```
Input: s = "  hello world  "
Output: "world hello"
Explanation: Your reversed string should not contain leading or trailing spaces.
```

Example 3:

```
Input: s = "a good   example"
Output: "example good a"
Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.
```


Constraints:

```
1 <= s.length <= 104
s contains English letters (upper-case and lower-case), digits, and spaces ' '.
There is at least one word in s.
```


Follow-up: If the string data type is mutable in your language, can you solve it in-place with O(1) extra space?

方法1：见注释：先去除空格，在从后往前挑单词进入list，最后把list用join连成str。

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        res = []

        # 第一步先去除首尾的空格
        def remove_outside_spaces(s):
            global s1
            l, r = 0, len(s) - 1
            while s[l] == ' ' :
                l += 1
                if s[l] != ' ':
                    break

            while s[r] == ' ':
                r -= 1
                if s[r] != ' ':
                    break
            s1 = s[l: r+1]
            return s1

        # 从后往前挑单词
        def select_words_from_back(s):
            right = len(s) - 1
            left = len(s) - 1

            while left >= 0:
                if s[left] != ' ':
                    if left == 0:
                        res.append(s[left: right+1])
                    left -= 1
                if s[left] == ' ':
                    res.append(s[left+1: right+1])
                    while(1):
                        left -= 1
                        if s[left] != ' ':
                            right = left
                            break
            return res
        # 执行上述两个函数
        remove_outside_spaces(s)
        select_words_from_back(s1)
        
        # 最后把list的内容合起来
        space = ' '
        return space.join(res)
```

方法2：python科技选手直接一行代码，中等题的水题实锤。（这样做没意思了，使用方法1是对中等题的基本尊重）

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        return (' ').join(s.split()[::-1])
```



## *例题4* 实现 strStr()

Implement strStr().

Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

Clarification:

What should we return when needle is an empty string? This is a great question to ask during an interview.

For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().

 

Example 1:

```
Input: haystack = "hello", needle = "ll"
Output: 2
```

Example 2:

```
Input: haystack = "aaaaa", needle = "bba"
Output: -1
```


Constraints:

```
1 <= haystack.length, needle.length <= 104
haystack and needle consist of only lowercase English characters.
```

方法：

```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        m = len(haystack)
        n = len(needle)
        if not needle: # needle为空时，返回值应该为0
            return 0

        for i in range(m-n+1):
            if haystack[i] == needle[0]:
                if haystack[i:i+n] == needle:  # 找到第一个匹配的字符后切片判断是否与needle相同
                    return i
        return -1
```

## 小结





## *例题1* 杨辉三角

Given an integer numRows, return the first numRows of Pascal's triangle.

In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:




Example 1:

```
Input: numRows = 5
Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
```

Example 2:

```
Input: numRows = 1
Output: [[1]]
```

方法：

```python
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        '''
        思路： 在杨辉三角中，每个数是它左上方和右上方的数的和
        方法： 每一行等于上一行前后错位后之和
                13310
               +01331
                14641
        '''
        ret = []
        for i in range(numRows):
            row = []
            for j in range(0, i+1):
                if j == 0 or j == i:
                    row.append(1)
                else:
                    row.append(ret[i-1][j] + ret[i-1][j-1])
            ret.append(row)
        return ret
```



## *例题2* 翻转字符串内的单词Ⅲ

Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.

 

Example 1:

```
Input: s = "Let's take LeetCode contest"
Output: "s'teL ekat edoCteeL tsetnoc"
```

Example 2:

```
Input: s = "God Ding"
Output: "doG gniD"
```


Constraints:

```
1 <= s.length <= 5 * 104
s contains printable ASCII characters.
s does not contain any leading or trailing spaces.
There is at least one word in s.
All the words in s are separated by a single space.
```

方法1：

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        l = 0
        r = 0
        res = []
        ret = ''
        while r < len(s):
            if s[r] != ' ':
                r += 1
                if r == len(s):
                    if l != 0:
                        res.append(s[r-1:l-1:-1])
                    else:
                        res.append(s[r-1::-1])
            elif s[r] == ' ':
                if l == 0:
                    res.append(s[r-1::-1])
                    r += 1
                    l = r
                    continue
                if l != 0:
                    res.append(s[r-1:l-1:-1])
                    r += 1
                    l = r

        ret = " ".join(res)
        return ret
```

方法2：可以用逆向切片来完成，一行代码即可。

```python
class Solution:
    def reverseWords(self, s: str) -> str:
		return " ".join(word[::-1] for word in s.split(" "))
        # 可以用逆向切片来完成
```

方法3：

利用栈的先进后出的结构很容易做到字符反转（在这里用队列的先进先出也是一样的，感兴趣的小伙伴可以自行试试，扩充对数据结构的理解）
但一串英文单词中，单词的个数总是比空格的字数多一个，在处理的时候很不方便
如：wordA(空格)wordB(空格)wordC
我们不妨在原字符串末尾补充一个空格，让每一小节都变成“单词+空格”（遇见空格就是我们判断出栈的前提条件）这样的形式。
预处理后：wordA(空格)wordB(空格)wordC(空格)
反转后：(空格)reversed_wordA(空格)reversed_wordB(空格)reversed_wordC
于是我们只要利用切片返回第一个字符后面的string就可以了。

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        stack, res, s = [], "", s + " "
        for i in s:
            stack.append(i)
            if i == " ":
                while(stack):
                    res += stack.pop()
        return res[1:]
```



## *例题3* 寻找旋转排序数组中的最小值

Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:

[4,5,6,7,0,1,2] if it was rotated 4 times.
[0,1,2,4,5,6,7] if it was rotated 7 times.
Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].

Given the sorted rotated array nums of unique elements, return the minimum element of this array.

You must write an algorithm that runs in O(log n) time.

 

Example 1:

```
Input: nums = [3,4,5,1,2]
Output: 1
Explanation: The original array was [1,2,3,4,5] rotated 3 times.
```

Example 2:

```
Input: nums = [4,5,6,7,0,1,2]
Output: 0
Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.
```

Example 3:

```
Input: nums = [11,13,15,17]
Output: 11
Explanation: The original array was [11,13,15,17] and it was rotated 4 times. 
```


Constraints:

```
n == nums.length
1 <= n <= 5000
-5000 <= nums[i] <= 5000
All the integers of nums are unique.
nums is sorted and rotated between 1 and n times.
```

方法1：由于数组是旋转的，所以可以考虑将其旋转回正常状态后，再直接输出第一个数字，它就是最小数字。什么时候是旋转回到正常状态呢？也就是第一个数字小于最后一个数字的时候就恢复正常了。

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        num_new = nums.copy() # 深复制，将两个数组放置不同地址，避免同时被修改。

        if len(nums) == 1:
            return nums[0]
        while 1:
            if num_new[0] < nums[-1]:
                break
            for i in range(len(nums)): # 旋转回去
                num_new[i] = nums[i-1]
            nums = num_new.copy()
        return nums[0]
```

方法2：机智的暴力解法，数组是被旋转了的，所以，在遍历过程中，只要有数字，小于了 nums[0]那么该数字一定是最小值，你品，你细品。

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        for i in range(len(nums)):
            if nums[i] < nums[0]:
                return nums[i]
        return nums[0]
```

方法3：二分法

首先，创建两个指针 left, right 分别指向 numbers 首尾数字，然后计算出两指针之间的中间索引值 middlem，然后我们会遇到以下三种情况：

middle > right ：代表最小值一定在 middle 右侧，所以 left 移到 middle + 1 的位置。
middle < right ：代表最小值一定在 middle 左侧或者就是 middle，所以 right 移到 middle 的位置。
middle 既不大于 left 指针的值，也不小于 right 指针的值，代表着 middle 可能等于 left 指针的值，或者 right 指针的值，我们这时候只能让 right指针递减，来一个一个找最小值了。

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:    
        low, high = 0, len(nums) - 1
        while low < high:
            pivot = low + (high - low) // 2
            if nums[pivot] < nums[high]:
                high = pivot 
            else:
                low = pivot + 1
        return nums[low]
```

方法4：直接简单的找最小值（打擂台，变量min）不写了。

## *例题4* 删除排序数组中的重复项

Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.

Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.

Return k after placing the final result in the first k slots of nums.

Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.

Custom Judge:

```
The judge will test your solution with the following code:

int[] nums = [...]; // Input array
int[] expectedNums = [...]; // The expected answer with correct length

int k = removeDuplicates(nums); // Calls your implementation

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
If all assertions pass, then your solution will be accepted.
```

 

Example 1:

```
Input: nums = [1,1,2]
Output: 2, nums = [1,2,_]
Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
```

Example 2:

```
Input: nums = [0,0,1,1,1,2,2,3,3,4]
Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]
Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
```


Constraints:

```
1 <= nums.length <= 3 * 104
-100 <= nums[i] <= 100
nums is sorted in non-decreasing order.
```

方法1：偷鸡方法 set

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        a = set(nums)  # 变成集合
        nums.clear()  # 清空列表
        a = list(a)  # 集合变列表
        nums.extend(a)  # 将集合添加到列表
        nums.sort()
        return len(nums) 
```

方法2：快慢指针

<img src="https://pic.leetcode-cn.com/1631552114-iGjdpt-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88.png" alt="快慢指针.png" style="zoom:67%;" />

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        slow = 0
        fast = 1

        while slow < len(nums) and fast < len(nums):
            if nums[slow] == nums[fast]:
                fast += 1
            elif nums[slow] != nums[fast]:
                slow += 1
                nums[slow] = nums[fast]
        return slow + 1
```



## *例题5* 移动零

Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.

Note that you must do this in-place without making a copy of the array.

 

Example 1:

```
Input: nums = [0,1,0,3,12]
Output: [1,3,12,0,0]
```

Example 2:

```
Input: nums = [0]
Output: [0]
```


Constraints:

```
1 <= nums.length <= 104
-231 <= nums[i] <= 231 - 1
```


Follow up: Could you minimize the total number of operations done?

方法1：冒泡排序0会打乱原来数字顺序，故换个思路可以冒泡交换非零元素，也是一种快慢双指针的思路。

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        l = 0
        for i in range(len(nums)):
            if nums[i] != 0:
                nums[i], nums[l] = nums[l], nums[i]
                l += 1
```

方法2：移除元素思路扩展，可以使用双指针将0全部删除，再在末尾添加相应个数的0元素。

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        slow = 0
        count = 0

        for fast in range(len(nums)):
            if nums[fast] != 0:
                nums[slow] = nums[fast]
                slow += 1
            else: # 顺便数0的个数，避免单独遍历增加时间复杂度
                count += 1
        # 添加0到末尾
        for i in range(1,count+1):
            nums[-i] = 0
```

## *例题6* 删除排序数组的重复项Ⅱ

Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.

Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.

Return k after placing the final result in the first k slots of nums.

Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.

Custom Judge:

The judge will test your solution with the following code:

int[] nums = [...]; // Input array
int[] expectedNums = [...]; // The expected answer with correct length

int k = removeDuplicates(nums); // Calls your implementation

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
If all assertions pass, then your solution will be accepted.

 

Example 1:

```
Input: nums = [1,1,1,2,2,3]
Output: 5, nums = [1,1,2,2,3,_]
Explanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
```

Example 2:

```
Input: nums = [0,0,1,1,1,1,2,3,3]
Output: 7, nums = [0,0,1,1,2,3,3,_,_]
Explanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
```


Constraints:

```
1 <= nums.length <= 3 * 104
-104 <= nums[i] <= 104
nums is sorted in non-decreasing order.
```

方法1：

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        slow = 1
		# 变动1: 由于元素可以重复2次，left现在从第二个元素开始，right从第三个元素开始
        for fast in range(2, len(nums)):
            # 变动2: 以前之和nums[left]比, 现在还要和nums[left - 1]比，从而保证元素可以重复两次
            if nums[fast] == nums[slow] and nums[fast] == nums[slow - 1]:
                continue
            slow += 1
            nums[slow] = nums[fast]
        return slow + 1
```

方法2：

```python
class Solution:
    def removeDuplicates(self, nums):
        n = len(nums)
        if (n <= 2):
            return n
        # nums[0...i]是符合要求的，
        i = 1
        k = i - 1
        j = i + 1
        while j <= n-1:
            if (nums[j] != nums[i]) or (nums[j] == nums[i] and nums[j] != nums[k]):
                k = i
                nums[i+1] = nums[j]
                i += 1
            j += 1

        return i + 1
```

扩展化，保留k个重复的元素：

```python
class Solution:
    def removeDuplicates(self, nums: List[int], K: int) -> int:
        slow = K - 1
        for fast in range(K, len(nums)):
            tag = True
            for i in range(K):
                tag *= nums[fast] == nums[slow - i]  # *= 是乘赋值操作。==号的结果是True或者是False
            if tag:
                continue

            slow += 1
            nums[slow] = nums[fast]
        return slow + 1
```

## *例题7* 颜色分类

Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.

We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.

You must solve this problem without using the library's sort function.

 

Example 1:

```
Input: nums = [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
```

Example 2:

```
Input: nums = [2,0,1]
Output: [0,1,2]
```


Constraints:

```
n == nums.length
1 <= n <= 300
nums[i] is either 0, 1, or 2.
```


Follow up: Could you come up with a one-pass algorithm using only constant extra space?

方法1：就直接一个简单排序，但是不被题目允许。。

```python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        for l in range(len(nums)):
            for r in range(l+1, len(nums)):
                if nums[l] > nums[r]:
                    nums[l], nums[r] = nums[r], nums[l]
```

方法2：单指针一次遍历
遇到0删掉放最左边，指针+1
遇到1不操作，指针+1
遇到2删掉，放最右边，指针不加，因为删了一位。
一开始在列表加了一个3，遇到3代表可以停止了，后面都是2。

```python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        nums.append(3)
        i = 0
        while nums[i] != 3:
            if nums[i] == 0:
                nums.pop(i)
                nums.insert(0, 0)
                i += 1
            elif nums[i] == 1:
                i += 1
            else:
                nums.append(nums.pop(i))
        num.pop(i)
```

方法3：单指针

```python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        n = len(nums)
        ptr = 0
        for i in range(n):
            if nums[i] == 0:
                nums[i], nums[ptr] = nums[ptr], nums[i]
                ptr += 1
        for i in range(ptr, n):
            if nums[i] == 1:
                nums[i], nums[ptr] = nums[ptr], nums[i]
                ptr += 1
```

方法4：

![image-20220809184311670](C:\Users\24372\AppData\Roaming\Typora\typora-user-images\image-20220809184311670.png)

```python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        n = len(nums)
        p0 = p1 = 0
        for i in range(n):
            if nums[i] == 1:
                nums[i], nums[p1] = nums[p1], nums[i]
                p1 += 1
            elif nums[i] == 0:
                nums[i], nums[p0] = nums[p0], nums[i]
                if p0 < p1:
                    nums[i], nums[p1] = nums[p1], nums[i]
                p0 += 1
                p1 += 1
```

方法5：

![image-20220809184742934](C:\Users\24372\AppData\Roaming\Typora\typora-user-images\image-20220809184742934.png)

```python
class Solution:
    def sortColors(self, nums):
        n = len(nums)

        lt = -1
        gt = n
        i = 0

        while i < gt:
            if nums[i] == 0:
                lt += 1
                nums[lt], nums[i] = nums[i], nums[lt]
                i += 1
            elif nums[i] == 2:
                gt -= 1
                nums[gt], nums[i] = nums[i], nums[gt]
            else:
                i += 1
                
        #  三路快速排序方法
		#  设置三个 lt, gt, i 定义：nums[0...lt] == 0，nums[lt+1...i-1] = 1，nums[gt...n-1] == 2，遍历一遍改数列保持这个定义。
```

## *例题8* 数组中的第K个最大元素

Given an integer array nums and an integer k, return the kth largest element in the array.

Note that it is the kth largest element in the sorted order, not the kth distinct element.

You must solve it in O(n) time complexity.

 

Example 1:

```
Input: nums = [3,2,1,5,6,4], k = 2
Output: 5
```

Example 2:

```
Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
Output: 4
```


Constraints:

```
1 <= k <= nums.length <= 105
-104 <= nums[i] <= 104
```

方法1：取巧方法。。。不建议用了。本题目目的是手写快排序和堆排序，调用库函数没有意义。

```python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        nums.sort()
        return nums[-k]
```

方法2：利用快速排序的思想，从数组 S 中随机找出一个元素 X，把数组分为两部分 Sa 和 Sb。Sa 中的元素大于等于 X，Sb 中元素小于 X。这时有两种情况：

Sa 中元素的个数小于 k，则 Sb 中的第 k-|Sa| 个元素即为第k大数；
Sa 中元素的个数大于等于 k，则返回 Sa 中的第 k 大数。时间复杂度近似为 O(n)

```python
class Solution:
    # 采用快速排序方法，分成的数列左边大于右边
    def findKthLargest(self, nums, k):
        n = len(nums)
        if (k > n):
            return
        index = self.quickSort(nums, 0, n-1, k)
        return nums[index]
        
    def quickSort(self, nums, l, r, k):
        if l >= r:
            return l
        p = self.partition(nums, l, r)
        if p + 1 == k:
            return p
        if p + 1 > k:
            return self.quickSort(nums, l, p -1, k)
        else:
            return self.quickSort(nums, p + 1, r, k)

    def partition(self, nums, l, r):
        v = nums[l]
        j = l
        i = l + 1
        while i <= r:
            if nums[i] >= v:
                nums[j+1],nums[i] = nums[i],nums[j+1]
                j += 1
            i += 1
        nums[l], nums[j] = nums[j], nums[l]
        return j
```

## *例题9* 合并两个有序数组

You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.

Merge nums1 and nums2 into a single array sorted in non-decreasing order.

The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.

 

Example 1:

```
Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]
Explanation: The arrays we are merging are [1,2,3] and [2,5,6].
The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.
```

Example 2:

```
Input: nums1 = [1], m = 1, nums2 = [], n = 0
Output: [1]
Explanation: The arrays we are merging are [1] and [].
The result of the merge is [1].
```

Example 3:

```
Input: nums1 = [0], m = 0, nums2 = [1], n = 1
Output: [1]
Explanation: The arrays we are merging are [] and [1].
The result of the merge is [1].
Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.
```


Constraints:

```
nums1.length == m + n
nums2.length == n
0 <= m, n <= 200
1 <= m + n <= 200
-109 <= nums1[i], nums2[j] <= 109
```


Follow up: Can you come up with an algorithm that runs in O(m + n) time?

方法1：直接把两个数组放在一起然后排序。

```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        i = m
        for j in range(n):
            nums1[i] = nums2[j]
            i += 1
        nums1.sort()
```

方法2：由于 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素，所以从 k=m+n-1 开始，分别遍历 nums1[m...0] 和 nums2[n...0] 中选取值大的。

```python
class Solution:
    def merge(self, nums1, m, nums2, n):
        
        # 尾插入法 
        if (n < 1):
            return
        if (m < 1):
            nums1[0:n] = nums2[0:n]
            return
        k = m + n - 1
        i = m - 1
        j = n - 1

        while k >= 0:
            if (nums1[i] > nums2[j] and i >= 0) or (j < 0 and i >= 0):
                nums1[k] = nums1[i]
                k -= 1
                i -= 1

            if (nums2[j] >= nums1[i] and j >= 0) or (i < 0 and j >=0):
                nums1[k] = nums2[j] 
                k -= 1
                j -= 1
```

## *例题10* 盛水最多的容器

You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).

Find two lines that together with the x-axis form a container, such that the container contains the most water.

Return the maximum amount of water a container can store.

Notice that you may not slant the container.

 ![img](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)

Example 1:

```
Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.
```


Example 2:

```
Input: height = [1,1]
Output: 1
```


Constraints:

```
n == height.length
2 <= n <= 105
0 <= height[i] <= 104
```

方法1：一次次遍历，把面积存入新的列表最后找出最大值。但是超时AC不了。

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        n = len(height)
        areas = []
        for i in range(n):
            for j in range(i+1, n):
                h = min(height[i], height[j])
                l = j - i
                areas.append(h*l)
        return max(areas)
```

方法2：

面积：短板的长度*短板与长板的距离
判断容积的时候，**因为只有短板才有影响，所以移动指针应该移动短板**，因为移动长板时，有：
**如果长板变得比短板还短，那么容积显然减少。**
**如果长板变得比短板长或相等，因为短板依旧未变。但距离减少，所以容积依旧减少。**
**但是如果你移动短板的话，就会有容积增大的可能。**

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        n = len(height)
        l = 0
        r = n-1
        maxarea = 0
        while l < r:
            maxarea = max(maxarea,min(height[l], height[r])*(r-l))
            if height[l] < height[r]:
                l += 1
            else:
                r -= 1
        return maxarea
```

